// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file AMM_Standard.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "AMM_Standard.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

AMM::FMA_Location::FMA_Location()
{
    m_FMAID = 0;



}

AMM::FMA_Location::~FMA_Location()
{
}

AMM::FMA_Location::FMA_Location(const FMA_Location &x)
{
    m_FMAID = x.m_FMAID;
    m_name = x.m_name;
}

AMM::FMA_Location::FMA_Location(FMA_Location &&x)
{
    m_FMAID = x.m_FMAID;
    m_name = std::move(x.m_name);
}

AMM::FMA_Location& AMM::FMA_Location::operator=(const FMA_Location &x)
{
    m_FMAID = x.m_FMAID;
    m_name = x.m_name;

    return *this;
}

AMM::FMA_Location& AMM::FMA_Location::operator=(FMA_Location &&x)
{
    m_FMAID = x.m_FMAID;
    m_name = std::move(x.m_name);

    return *this;
}

size_t AMM::FMA_Location::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::FMA_Location::getCdrSerializedSize(const AMM::FMA_Location& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::FMA_Location::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_FMAID;
    scdr << m_name;
}

void AMM::FMA_Location::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_FMAID;
    dcdr >> m_name;
}

size_t AMM::FMA_Location::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool AMM::FMA_Location::isKeyDefined()
{
    return false;
}

void AMM::FMA_Location::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
AMM::UUID::UUID()
{

}

AMM::UUID::~UUID()
{
}

AMM::UUID::UUID(const UUID &x)
{
    m_id = x.m_id;
}

AMM::UUID::UUID(UUID &&x)
{
    m_id = std::move(x.m_id);
}

AMM::UUID& AMM::UUID::operator=(const UUID &x)
{
    m_id = x.m_id;

    return *this;
}

AMM::UUID& AMM::UUID::operator=(UUID &&x)
{
    m_id = std::move(x.m_id);

    return *this;
}

size_t AMM::UUID::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t AMM::UUID::getCdrSerializedSize(const AMM::UUID& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.id().size() + 1;

    return current_alignment - initial_alignment;
}

void AMM::UUID::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_id;
}

void AMM::UUID::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_id;
}

size_t AMM::UUID::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool AMM::UUID::isKeyDefined()
{
    return false;
}

void AMM::UUID::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
}

AMM::Assessment::Assessment()
{


    m_value = AMM::OMISSION_ERROR;



}

AMM::Assessment::~Assessment()
{
}

AMM::Assessment::Assessment(const Assessment &x)
{
    m_id = x.m_id;
    m_event_id = x.m_event_id;
    m_value = x.m_value;
    m_comment = x.m_comment;
}

AMM::Assessment::Assessment(Assessment &&x)
{
    m_id = std::move(x.m_id);
    m_event_id = std::move(x.m_event_id);
    m_value = x.m_value;
    m_comment = std::move(x.m_comment);
}

AMM::Assessment& AMM::Assessment::operator=(const Assessment &x)
{
    m_id = x.m_id;
    m_event_id = x.m_event_id;
    m_value = x.m_value;
    m_comment = x.m_comment;

    return *this;
}

AMM::Assessment& AMM::Assessment::operator=(Assessment &&x)
{
    m_id = std::move(x.m_id);
    m_event_id = std::move(x.m_event_id);
    m_value = x.m_value;
    m_comment = std::move(x.m_comment);

    return *this;
}

size_t AMM::Assessment::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Assessment::getCdrSerializedSize(const AMM::Assessment& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += AMM::UUID::getCdrSerializedSize(data.event_id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.comment().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Assessment::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_id;
    scdr << m_event_id;
    scdr << (uint32_t)m_value;
    scdr << m_comment;
}

void AMM::Assessment::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_id;
    dcdr >> m_event_id;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_value = (AMM::AssessmentValue)enum_value;
    }
    dcdr >> m_comment;
}

size_t AMM::Assessment::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            





    return current_align;
}

bool AMM::Assessment::isKeyDefined()
{
    return false;
}

void AMM::Assessment::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
}

AMM::EventFragment::EventFragment()
{

    m_timestamp = 0;



    m_agent_type = AMM::LEARNER;





}

AMM::EventFragment::~EventFragment()
{
}

AMM::EventFragment::EventFragment(const EventFragment &x)
{
    m_id = x.m_id;
    m_timestamp = x.m_timestamp;
    m_educational_encounter = x.m_educational_encounter;
    m_location = x.m_location;
    m_agent_type = x.m_agent_type;
    m_agent_id = x.m_agent_id;
    m_type = x.m_type;
    m_data = x.m_data;
}

AMM::EventFragment::EventFragment(EventFragment &&x)
{
    m_id = std::move(x.m_id);
    m_timestamp = x.m_timestamp;
    m_educational_encounter = std::move(x.m_educational_encounter);
    m_location = std::move(x.m_location);
    m_agent_type = x.m_agent_type;
    m_agent_id = std::move(x.m_agent_id);
    m_type = std::move(x.m_type);
    m_data = std::move(x.m_data);
}

AMM::EventFragment& AMM::EventFragment::operator=(const EventFragment &x)
{
    m_id = x.m_id;
    m_timestamp = x.m_timestamp;
    m_educational_encounter = x.m_educational_encounter;
    m_location = x.m_location;
    m_agent_type = x.m_agent_type;
    m_agent_id = x.m_agent_id;
    m_type = x.m_type;
    m_data = x.m_data;

    return *this;
}

AMM::EventFragment& AMM::EventFragment::operator=(EventFragment &&x)
{
    m_id = std::move(x.m_id);
    m_timestamp = x.m_timestamp;
    m_educational_encounter = std::move(x.m_educational_encounter);
    m_location = std::move(x.m_location);
    m_agent_type = x.m_agent_type;
    m_agent_id = std::move(x.m_agent_id);
    m_type = std::move(x.m_type);
    m_data = std::move(x.m_data);

    return *this;
}

size_t AMM::EventFragment::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += AMM::FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::EventFragment::getCdrSerializedSize(const AMM::EventFragment& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += AMM::UUID::getCdrSerializedSize(data.educational_encounter(), current_alignment);
    current_alignment += AMM::FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AMM::UUID::getCdrSerializedSize(data.agent_id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.data().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::EventFragment::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_id;
    scdr << m_timestamp;
    scdr << m_educational_encounter;
    scdr << m_location;
    scdr << (uint32_t)m_agent_type;
    scdr << m_agent_id;
    scdr << m_type;
    scdr << m_data;
}

void AMM::EventFragment::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_id;
    dcdr >> m_timestamp;
    dcdr >> m_educational_encounter;
    dcdr >> m_location;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_agent_type = (AMM::EventAgentType)enum_value;
    }
    dcdr >> m_agent_id;
    dcdr >> m_type;
    dcdr >> m_data;
}

size_t AMM::EventFragment::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            









    return current_align;
}

bool AMM::EventFragment::isKeyDefined()
{
    return false;
}

void AMM::EventFragment::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
	 
}
AMM::EventRecord::EventRecord()
{

    m_timestamp = 0;



    m_agent_type = AMM::LEARNER;





}

AMM::EventRecord::~EventRecord()
{
}

AMM::EventRecord::EventRecord(const EventRecord &x)
{
    m_id = x.m_id;
    m_timestamp = x.m_timestamp;
    m_educational_encounter = x.m_educational_encounter;
    m_location = x.m_location;
    m_agent_type = x.m_agent_type;
    m_agent_id = x.m_agent_id;
    m_type = x.m_type;
    m_data = x.m_data;
}

AMM::EventRecord::EventRecord(EventRecord &&x)
{
    m_id = std::move(x.m_id);
    m_timestamp = x.m_timestamp;
    m_educational_encounter = std::move(x.m_educational_encounter);
    m_location = std::move(x.m_location);
    m_agent_type = x.m_agent_type;
    m_agent_id = std::move(x.m_agent_id);
    m_type = std::move(x.m_type);
    m_data = std::move(x.m_data);
}

AMM::EventRecord& AMM::EventRecord::operator=(const EventRecord &x)
{
    m_id = x.m_id;
    m_timestamp = x.m_timestamp;
    m_educational_encounter = x.m_educational_encounter;
    m_location = x.m_location;
    m_agent_type = x.m_agent_type;
    m_agent_id = x.m_agent_id;
    m_type = x.m_type;
    m_data = x.m_data;

    return *this;
}

AMM::EventRecord& AMM::EventRecord::operator=(EventRecord &&x)
{
    m_id = std::move(x.m_id);
    m_timestamp = x.m_timestamp;
    m_educational_encounter = std::move(x.m_educational_encounter);
    m_location = std::move(x.m_location);
    m_agent_type = x.m_agent_type;
    m_agent_id = std::move(x.m_agent_id);
    m_type = std::move(x.m_type);
    m_data = std::move(x.m_data);

    return *this;
}

size_t AMM::EventRecord::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += AMM::FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::EventRecord::getCdrSerializedSize(const AMM::EventRecord& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += AMM::UUID::getCdrSerializedSize(data.educational_encounter(), current_alignment);
    current_alignment += AMM::FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AMM::UUID::getCdrSerializedSize(data.agent_id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.data().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::EventRecord::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_id;
    scdr << m_timestamp;
    scdr << m_educational_encounter;
    scdr << m_location;
    scdr << (uint32_t)m_agent_type;
    scdr << m_agent_id;
    scdr << m_type;
    scdr << m_data;
}

void AMM::EventRecord::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_id;
    dcdr >> m_timestamp;
    dcdr >> m_educational_encounter;
    dcdr >> m_location;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_agent_type = (AMM::EventAgentType)enum_value;
    }
    dcdr >> m_agent_id;
    dcdr >> m_type;
    dcdr >> m_data;
}

size_t AMM::EventRecord::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            









    return current_align;
}

bool AMM::EventRecord::isKeyDefined()
{
    return false;
}

void AMM::EventRecord::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
	 
}

AMM::FragmentAmendmentRequest::FragmentAmendmentRequest()
{


    m_status = AMM::REQUESTING;


    m_agent_type = AMM::LEARNER;



}

AMM::FragmentAmendmentRequest::~FragmentAmendmentRequest()
{
}

AMM::FragmentAmendmentRequest::FragmentAmendmentRequest(const FragmentAmendmentRequest &x)
{
    m_id = x.m_id;
    m_fragment_id = x.m_fragment_id;
    m_status = x.m_status;
    m_location = x.m_location;
    m_agent_type = x.m_agent_type;
    m_agent_id = x.m_agent_id;
}

AMM::FragmentAmendmentRequest::FragmentAmendmentRequest(FragmentAmendmentRequest &&x)
{
    m_id = std::move(x.m_id);
    m_fragment_id = std::move(x.m_fragment_id);
    m_status = x.m_status;
    m_location = std::move(x.m_location);
    m_agent_type = x.m_agent_type;
    m_agent_id = std::move(x.m_agent_id);
}

AMM::FragmentAmendmentRequest& AMM::FragmentAmendmentRequest::operator=(const FragmentAmendmentRequest &x)
{
    m_id = x.m_id;
    m_fragment_id = x.m_fragment_id;
    m_status = x.m_status;
    m_location = x.m_location;
    m_agent_type = x.m_agent_type;
    m_agent_id = x.m_agent_id;

    return *this;
}

AMM::FragmentAmendmentRequest& AMM::FragmentAmendmentRequest::operator=(FragmentAmendmentRequest &&x)
{
    m_id = std::move(x.m_id);
    m_fragment_id = std::move(x.m_fragment_id);
    m_status = x.m_status;
    m_location = std::move(x.m_location);
    m_agent_type = x.m_agent_type;
    m_agent_id = std::move(x.m_agent_id);

    return *this;
}

size_t AMM::FragmentAmendmentRequest::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AMM::FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t AMM::FragmentAmendmentRequest::getCdrSerializedSize(const AMM::FragmentAmendmentRequest& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += AMM::UUID::getCdrSerializedSize(data.fragment_id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AMM::FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AMM::UUID::getCdrSerializedSize(data.agent_id(), current_alignment);

    return current_alignment - initial_alignment;
}

void AMM::FragmentAmendmentRequest::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_id;
    scdr << m_fragment_id;
    scdr << (uint32_t)m_status;
    scdr << m_location;
    scdr << (uint32_t)m_agent_type;
    scdr << m_agent_id;
}

void AMM::FragmentAmendmentRequest::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_id;
    dcdr >> m_fragment_id;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_status = (AMM::FAR_Status)enum_value;
    }
    dcdr >> m_location;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_agent_type = (AMM::EventAgentType)enum_value;
    }
    dcdr >> m_agent_id;
}

size_t AMM::FragmentAmendmentRequest::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            







    return current_align;
}

bool AMM::FragmentAmendmentRequest::isKeyDefined()
{
    return false;
}

void AMM::FragmentAmendmentRequest::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
}

AMM::Log::Log()
{
    m_timestamp = 0;


    m_level = AMM::L_FATAL;



}

AMM::Log::~Log()
{
}

AMM::Log::Log(const Log &x)
{
    m_timestamp = x.m_timestamp;
    m_module_id = x.m_module_id;
    m_level = x.m_level;
    m_message = x.m_message;
}

AMM::Log::Log(Log &&x)
{
    m_timestamp = x.m_timestamp;
    m_module_id = std::move(x.m_module_id);
    m_level = x.m_level;
    m_message = std::move(x.m_message);
}

AMM::Log& AMM::Log::operator=(const Log &x)
{
    m_timestamp = x.m_timestamp;
    m_module_id = x.m_module_id;
    m_level = x.m_level;
    m_message = x.m_message;

    return *this;
}

AMM::Log& AMM::Log::operator=(Log &&x)
{
    m_timestamp = x.m_timestamp;
    m_module_id = std::move(x.m_module_id);
    m_level = x.m_level;
    m_message = std::move(x.m_message);

    return *this;
}

size_t AMM::Log::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Log::getCdrSerializedSize(const AMM::Log& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += AMM::UUID::getCdrSerializedSize(data.module_id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.message().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Log::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_timestamp;
    scdr << m_module_id;
    scdr << (uint32_t)m_level;
    scdr << m_message;
}

void AMM::Log::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_timestamp;
    dcdr >> m_module_id;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_level = (AMM::LogLevel)enum_value;
    }
    dcdr >> m_message;
}

size_t AMM::Log::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            





    return current_align;
}

bool AMM::Log::isKeyDefined()
{
    return false;
}

void AMM::Log::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
}
AMM::ModuleConfiguration::ModuleConfiguration()
{



    m_timestamp = 0;



}

AMM::ModuleConfiguration::~ModuleConfiguration()
{
}

AMM::ModuleConfiguration::ModuleConfiguration(const ModuleConfiguration &x)
{
    m_name = x.m_name;
    m_module_id = x.m_module_id;
    m_educational_encounter = x.m_educational_encounter;
    m_timestamp = x.m_timestamp;
    m_capabilities_configuration = x.m_capabilities_configuration;
}

AMM::ModuleConfiguration::ModuleConfiguration(ModuleConfiguration &&x)
{
    m_name = std::move(x.m_name);
    m_module_id = std::move(x.m_module_id);
    m_educational_encounter = std::move(x.m_educational_encounter);
    m_timestamp = x.m_timestamp;
    m_capabilities_configuration = std::move(x.m_capabilities_configuration);
}

AMM::ModuleConfiguration& AMM::ModuleConfiguration::operator=(const ModuleConfiguration &x)
{
    m_name = x.m_name;
    m_module_id = x.m_module_id;
    m_educational_encounter = x.m_educational_encounter;
    m_timestamp = x.m_timestamp;
    m_capabilities_configuration = x.m_capabilities_configuration;

    return *this;
}

AMM::ModuleConfiguration& AMM::ModuleConfiguration::operator=(ModuleConfiguration &&x)
{
    m_name = std::move(x.m_name);
    m_module_id = std::move(x.m_module_id);
    m_educational_encounter = std::move(x.m_educational_encounter);
    m_timestamp = x.m_timestamp;
    m_capabilities_configuration = std::move(x.m_capabilities_configuration);

    return *this;
}

size_t AMM::ModuleConfiguration::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::ModuleConfiguration::getCdrSerializedSize(const AMM::ModuleConfiguration& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += AMM::UUID::getCdrSerializedSize(data.module_id(), current_alignment);
    current_alignment += AMM::UUID::getCdrSerializedSize(data.educational_encounter(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.capabilities_configuration().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::ModuleConfiguration::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_name;
    scdr << m_module_id;
    scdr << m_educational_encounter;
    scdr << m_timestamp;
    scdr << m_capabilities_configuration;
}

void AMM::ModuleConfiguration::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_name;
    dcdr >> m_module_id;
    dcdr >> m_educational_encounter;
    dcdr >> m_timestamp;
    dcdr >> m_capabilities_configuration;
}

size_t AMM::ModuleConfiguration::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            






    return current_align;
}

bool AMM::ModuleConfiguration::isKeyDefined()
{
    return false;
}

void AMM::ModuleConfiguration::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
}
AMM::OmittedEvent::OmittedEvent()
{

    m_timestamp = 0;



    m_agent_type = AMM::LEARNER;





}

AMM::OmittedEvent::~OmittedEvent()
{
}

AMM::OmittedEvent::OmittedEvent(const OmittedEvent &x)
{
    m_id = x.m_id;
    m_timestamp = x.m_timestamp;
    m_educational_encounter = x.m_educational_encounter;
    m_location = x.m_location;
    m_agent_type = x.m_agent_type;
    m_agent_id = x.m_agent_id;
    m_type = x.m_type;
    m_data = x.m_data;
}

AMM::OmittedEvent::OmittedEvent(OmittedEvent &&x)
{
    m_id = std::move(x.m_id);
    m_timestamp = x.m_timestamp;
    m_educational_encounter = std::move(x.m_educational_encounter);
    m_location = std::move(x.m_location);
    m_agent_type = x.m_agent_type;
    m_agent_id = std::move(x.m_agent_id);
    m_type = std::move(x.m_type);
    m_data = std::move(x.m_data);
}

AMM::OmittedEvent& AMM::OmittedEvent::operator=(const OmittedEvent &x)
{
    m_id = x.m_id;
    m_timestamp = x.m_timestamp;
    m_educational_encounter = x.m_educational_encounter;
    m_location = x.m_location;
    m_agent_type = x.m_agent_type;
    m_agent_id = x.m_agent_id;
    m_type = x.m_type;
    m_data = x.m_data;

    return *this;
}

AMM::OmittedEvent& AMM::OmittedEvent::operator=(OmittedEvent &&x)
{
    m_id = std::move(x.m_id);
    m_timestamp = x.m_timestamp;
    m_educational_encounter = std::move(x.m_educational_encounter);
    m_location = std::move(x.m_location);
    m_agent_type = x.m_agent_type;
    m_agent_id = std::move(x.m_agent_id);
    m_type = std::move(x.m_type);
    m_data = std::move(x.m_data);

    return *this;
}

size_t AMM::OmittedEvent::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += AMM::FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::OmittedEvent::getCdrSerializedSize(const AMM::OmittedEvent& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += AMM::UUID::getCdrSerializedSize(data.educational_encounter(), current_alignment);
    current_alignment += AMM::FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AMM::UUID::getCdrSerializedSize(data.agent_id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.data().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::OmittedEvent::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_id;
    scdr << m_timestamp;
    scdr << m_educational_encounter;
    scdr << m_location;
    scdr << (uint32_t)m_agent_type;
    scdr << m_agent_id;
    scdr << m_type;
    scdr << m_data;
}

void AMM::OmittedEvent::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_id;
    dcdr >> m_timestamp;
    dcdr >> m_educational_encounter;
    dcdr >> m_location;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_agent_type = (AMM::EventAgentType)enum_value;
    }
    dcdr >> m_agent_id;
    dcdr >> m_type;
    dcdr >> m_data;
}

size_t AMM::OmittedEvent::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            









    return current_align;
}

bool AMM::OmittedEvent::isKeyDefined()
{
    return false;
}

void AMM::OmittedEvent::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
	 
}
AMM::Semantic_Version::Semantic_Version()
{
    m_major = 0;

    m_minor = 0;

    m_patch = 0;


}

AMM::Semantic_Version::~Semantic_Version()
{
}

AMM::Semantic_Version::Semantic_Version(const Semantic_Version &x)
{
    m_major = x.m_major;
    m_minor = x.m_minor;
    m_patch = x.m_patch;
}

AMM::Semantic_Version::Semantic_Version(Semantic_Version &&x)
{
    m_major = x.m_major;
    m_minor = x.m_minor;
    m_patch = x.m_patch;
}

AMM::Semantic_Version& AMM::Semantic_Version::operator=(const Semantic_Version &x)
{
    m_major = x.m_major;
    m_minor = x.m_minor;
    m_patch = x.m_patch;

    return *this;
}

AMM::Semantic_Version& AMM::Semantic_Version::operator=(Semantic_Version &&x)
{
    m_major = x.m_major;
    m_minor = x.m_minor;
    m_patch = x.m_patch;

    return *this;
}

size_t AMM::Semantic_Version::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

size_t AMM::Semantic_Version::getCdrSerializedSize(const AMM::Semantic_Version& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

void AMM::Semantic_Version::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_major;
    scdr << m_minor;
    scdr << m_patch;
}

void AMM::Semantic_Version::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_major;
    dcdr >> m_minor;
    dcdr >> m_patch;
}

size_t AMM::Semantic_Version::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool AMM::Semantic_Version::isKeyDefined()
{
    return false;
}

void AMM::Semantic_Version::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}
AMM::OperationalDescription::OperationalDescription()
{









    memset(&m_ip_address, 0, (4) * 1);


}

AMM::OperationalDescription::~OperationalDescription()
{
}

AMM::OperationalDescription::OperationalDescription(const OperationalDescription &x)
{
    m_name = x.m_name;
    m_description = x.m_description;
    m_manufacturer = x.m_manufacturer;
    m_model = x.m_model;
    m_serial_number = x.m_serial_number;
    m_module_id = x.m_module_id;
    m_module_version = x.m_module_version;
    m_configuration_version = x.m_configuration_version;
    m_AMM_version = x.m_AMM_version;
    m_ip_address = x.m_ip_address;
    m_capabilities_schema = x.m_capabilities_schema;
}

AMM::OperationalDescription::OperationalDescription(OperationalDescription &&x)
{
    m_name = std::move(x.m_name);
    m_description = std::move(x.m_description);
    m_manufacturer = std::move(x.m_manufacturer);
    m_model = std::move(x.m_model);
    m_serial_number = std::move(x.m_serial_number);
    m_module_id = std::move(x.m_module_id);
    m_module_version = std::move(x.m_module_version);
    m_configuration_version = std::move(x.m_configuration_version);
    m_AMM_version = std::move(x.m_AMM_version);
    m_ip_address = std::move(x.m_ip_address);
    m_capabilities_schema = std::move(x.m_capabilities_schema);
}

AMM::OperationalDescription& AMM::OperationalDescription::operator=(const OperationalDescription &x)
{
    m_name = x.m_name;
    m_description = x.m_description;
    m_manufacturer = x.m_manufacturer;
    m_model = x.m_model;
    m_serial_number = x.m_serial_number;
    m_module_id = x.m_module_id;
    m_module_version = x.m_module_version;
    m_configuration_version = x.m_configuration_version;
    m_AMM_version = x.m_AMM_version;
    m_ip_address = x.m_ip_address;
    m_capabilities_schema = x.m_capabilities_schema;

    return *this;
}

AMM::OperationalDescription& AMM::OperationalDescription::operator=(OperationalDescription &&x)
{
    m_name = std::move(x.m_name);
    m_description = std::move(x.m_description);
    m_manufacturer = std::move(x.m_manufacturer);
    m_model = std::move(x.m_model);
    m_serial_number = std::move(x.m_serial_number);
    m_module_id = std::move(x.m_module_id);
    m_module_version = std::move(x.m_module_version);
    m_configuration_version = std::move(x.m_configuration_version);
    m_AMM_version = std::move(x.m_AMM_version);
    m_ip_address = std::move(x.m_ip_address);
    m_capabilities_schema = std::move(x.m_capabilities_schema);

    return *this;
}

size_t AMM::OperationalDescription::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::OperationalDescription::getCdrSerializedSize(const AMM::OperationalDescription& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.description().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.manufacturer().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.model().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.serial_number().size() + 1;

    current_alignment += AMM::UUID::getCdrSerializedSize(data.module_id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.module_version().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.configuration_version().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.AMM_version().size() + 1;

    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.capabilities_schema().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::OperationalDescription::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_name;
    scdr << m_description;
    scdr << m_manufacturer;
    scdr << m_model;
    scdr << m_serial_number;
    scdr << m_module_id;
    scdr << m_module_version;
    scdr << m_configuration_version;
    scdr << m_AMM_version;
    scdr << m_ip_address;
    scdr << m_capabilities_schema;
}

void AMM::OperationalDescription::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_name;
    dcdr >> m_description;
    dcdr >> m_manufacturer;
    dcdr >> m_model;
    dcdr >> m_serial_number;
    dcdr >> m_module_id;
    dcdr >> m_module_version;
    dcdr >> m_configuration_version;
    dcdr >> m_AMM_version;
    dcdr >> m_ip_address;
    dcdr >> m_capabilities_schema;
}

size_t AMM::OperationalDescription::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            












    return current_align;
}

bool AMM::OperationalDescription::isKeyDefined()
{
    return false;
}

void AMM::OperationalDescription::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
}
AMM::PhysiologyModification::PhysiologyModification()
{





}

AMM::PhysiologyModification::~PhysiologyModification()
{
}

AMM::PhysiologyModification::PhysiologyModification(const PhysiologyModification &x)
{
    m_id = x.m_id;
    m_event_id = x.m_event_id;
    m_type = x.m_type;
    m_data = x.m_data;
}

AMM::PhysiologyModification::PhysiologyModification(PhysiologyModification &&x)
{
    m_id = std::move(x.m_id);
    m_event_id = std::move(x.m_event_id);
    m_type = std::move(x.m_type);
    m_data = std::move(x.m_data);
}

AMM::PhysiologyModification& AMM::PhysiologyModification::operator=(const PhysiologyModification &x)
{
    m_id = x.m_id;
    m_event_id = x.m_event_id;
    m_type = x.m_type;
    m_data = x.m_data;

    return *this;
}

AMM::PhysiologyModification& AMM::PhysiologyModification::operator=(PhysiologyModification &&x)
{
    m_id = std::move(x.m_id);
    m_event_id = std::move(x.m_event_id);
    m_type = std::move(x.m_type);
    m_data = std::move(x.m_data);

    return *this;
}

size_t AMM::PhysiologyModification::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::PhysiologyModification::getCdrSerializedSize(const AMM::PhysiologyModification& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += AMM::UUID::getCdrSerializedSize(data.event_id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.data().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::PhysiologyModification::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_id;
    scdr << m_event_id;
    scdr << m_type;
    scdr << m_data;
}

void AMM::PhysiologyModification::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_id;
    dcdr >> m_event_id;
    dcdr >> m_type;
    dcdr >> m_data;
}

size_t AMM::PhysiologyModification::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            





    return current_align;
}

bool AMM::PhysiologyModification::isKeyDefined()
{
    return false;
}

void AMM::PhysiologyModification::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
}
AMM::PhysiologyValue::PhysiologyValue()
{

    m_simulation_time = 0;

    m_timestamp = 0;



    m_value = 0.0;


}

AMM::PhysiologyValue::~PhysiologyValue()
{
}

AMM::PhysiologyValue::PhysiologyValue(const PhysiologyValue &x)
{
    m_educational_encounter = x.m_educational_encounter;
    m_simulation_time = x.m_simulation_time;
    m_timestamp = x.m_timestamp;
    m_name = x.m_name;
    m_unit = x.m_unit;
    m_value = x.m_value;
}

AMM::PhysiologyValue::PhysiologyValue(PhysiologyValue &&x)
{
    m_educational_encounter = std::move(x.m_educational_encounter);
    m_simulation_time = x.m_simulation_time;
    m_timestamp = x.m_timestamp;
    m_name = std::move(x.m_name);
    m_unit = std::move(x.m_unit);
    m_value = x.m_value;
}

AMM::PhysiologyValue& AMM::PhysiologyValue::operator=(const PhysiologyValue &x)
{
    m_educational_encounter = x.m_educational_encounter;
    m_simulation_time = x.m_simulation_time;
    m_timestamp = x.m_timestamp;
    m_name = x.m_name;
    m_unit = x.m_unit;
    m_value = x.m_value;

    return *this;
}

AMM::PhysiologyValue& AMM::PhysiologyValue::operator=(PhysiologyValue &&x)
{
    m_educational_encounter = std::move(x.m_educational_encounter);
    m_simulation_time = x.m_simulation_time;
    m_timestamp = x.m_timestamp;
    m_name = std::move(x.m_name);
    m_unit = std::move(x.m_unit);
    m_value = x.m_value;

    return *this;
}

size_t AMM::PhysiologyValue::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t AMM::PhysiologyValue::getCdrSerializedSize(const AMM::PhysiologyValue& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getCdrSerializedSize(data.educational_encounter(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.unit().size() + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void AMM::PhysiologyValue::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_educational_encounter;
    scdr << m_simulation_time;
    scdr << m_timestamp;
    scdr << m_name;
    scdr << m_unit;
    scdr << m_value;
}

void AMM::PhysiologyValue::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_educational_encounter;
    dcdr >> m_simulation_time;
    dcdr >> m_timestamp;
    dcdr >> m_name;
    dcdr >> m_unit;
    dcdr >> m_value;
}

size_t AMM::PhysiologyValue::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            







    return current_align;
}

bool AMM::PhysiologyValue::isKeyDefined()
{
    return false;
}

void AMM::PhysiologyValue::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
}
AMM::PhysiologyWaveform::PhysiologyWaveform()
{

    m_simulation_time = 0;

    m_timestamp = 0;



    m_value = 0.0;


}

AMM::PhysiologyWaveform::~PhysiologyWaveform()
{
}

AMM::PhysiologyWaveform::PhysiologyWaveform(const PhysiologyWaveform &x)
{
    m_educational_encounter = x.m_educational_encounter;
    m_simulation_time = x.m_simulation_time;
    m_timestamp = x.m_timestamp;
    m_name = x.m_name;
    m_unit = x.m_unit;
    m_value = x.m_value;
}

AMM::PhysiologyWaveform::PhysiologyWaveform(PhysiologyWaveform &&x)
{
    m_educational_encounter = std::move(x.m_educational_encounter);
    m_simulation_time = x.m_simulation_time;
    m_timestamp = x.m_timestamp;
    m_name = std::move(x.m_name);
    m_unit = std::move(x.m_unit);
    m_value = x.m_value;
}

AMM::PhysiologyWaveform& AMM::PhysiologyWaveform::operator=(const PhysiologyWaveform &x)
{
    m_educational_encounter = x.m_educational_encounter;
    m_simulation_time = x.m_simulation_time;
    m_timestamp = x.m_timestamp;
    m_name = x.m_name;
    m_unit = x.m_unit;
    m_value = x.m_value;

    return *this;
}

AMM::PhysiologyWaveform& AMM::PhysiologyWaveform::operator=(PhysiologyWaveform &&x)
{
    m_educational_encounter = std::move(x.m_educational_encounter);
    m_simulation_time = x.m_simulation_time;
    m_timestamp = x.m_timestamp;
    m_name = std::move(x.m_name);
    m_unit = std::move(x.m_unit);
    m_value = x.m_value;

    return *this;
}

size_t AMM::PhysiologyWaveform::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t AMM::PhysiologyWaveform::getCdrSerializedSize(const AMM::PhysiologyWaveform& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getCdrSerializedSize(data.educational_encounter(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.unit().size() + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void AMM::PhysiologyWaveform::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_educational_encounter;
    scdr << m_simulation_time;
    scdr << m_timestamp;
    scdr << m_name;
    scdr << m_unit;
    scdr << m_value;
}

void AMM::PhysiologyWaveform::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_educational_encounter;
    dcdr >> m_simulation_time;
    dcdr >> m_timestamp;
    dcdr >> m_name;
    dcdr >> m_unit;
    dcdr >> m_value;
}

size_t AMM::PhysiologyWaveform::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            







    return current_align;
}

bool AMM::PhysiologyWaveform::isKeyDefined()
{
    return false;
}

void AMM::PhysiologyWaveform::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
}
AMM::RenderModification::RenderModification()
{





}

AMM::RenderModification::~RenderModification()
{
}

AMM::RenderModification::RenderModification(const RenderModification &x)
{
    m_id = x.m_id;
    m_event_id = x.m_event_id;
    m_type = x.m_type;
    m_data = x.m_data;
}

AMM::RenderModification::RenderModification(RenderModification &&x)
{
    m_id = std::move(x.m_id);
    m_event_id = std::move(x.m_event_id);
    m_type = std::move(x.m_type);
    m_data = std::move(x.m_data);
}

AMM::RenderModification& AMM::RenderModification::operator=(const RenderModification &x)
{
    m_id = x.m_id;
    m_event_id = x.m_event_id;
    m_type = x.m_type;
    m_data = x.m_data;

    return *this;
}

AMM::RenderModification& AMM::RenderModification::operator=(RenderModification &&x)
{
    m_id = std::move(x.m_id);
    m_event_id = std::move(x.m_event_id);
    m_type = std::move(x.m_type);
    m_data = std::move(x.m_data);

    return *this;
}

size_t AMM::RenderModification::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::RenderModification::getCdrSerializedSize(const AMM::RenderModification& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += AMM::UUID::getCdrSerializedSize(data.event_id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.data().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::RenderModification::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_id;
    scdr << m_event_id;
    scdr << m_type;
    scdr << m_data;
}

void AMM::RenderModification::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_id;
    dcdr >> m_event_id;
    dcdr >> m_type;
    dcdr >> m_data;
}

size_t AMM::RenderModification::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            





    return current_align;
}

bool AMM::RenderModification::isKeyDefined()
{
    return false;
}

void AMM::RenderModification::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
}

AMM::SimulationControl::SimulationControl()
{
    m_timestamp = 0;

    m_type = AMM::RUN;



}

AMM::SimulationControl::~SimulationControl()
{
}

AMM::SimulationControl::SimulationControl(const SimulationControl &x)
{
    m_timestamp = x.m_timestamp;
    m_type = x.m_type;
    m_educational_encounter = x.m_educational_encounter;
}

AMM::SimulationControl::SimulationControl(SimulationControl &&x)
{
    m_timestamp = x.m_timestamp;
    m_type = x.m_type;
    m_educational_encounter = std::move(x.m_educational_encounter);
}

AMM::SimulationControl& AMM::SimulationControl::operator=(const SimulationControl &x)
{
    m_timestamp = x.m_timestamp;
    m_type = x.m_type;
    m_educational_encounter = x.m_educational_encounter;

    return *this;
}

AMM::SimulationControl& AMM::SimulationControl::operator=(SimulationControl &&x)
{
    m_timestamp = x.m_timestamp;
    m_type = x.m_type;
    m_educational_encounter = std::move(x.m_educational_encounter);

    return *this;
}

size_t AMM::SimulationControl::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t AMM::SimulationControl::getCdrSerializedSize(const AMM::SimulationControl& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AMM::UUID::getCdrSerializedSize(data.educational_encounter(), current_alignment);

    return current_alignment - initial_alignment;
}

void AMM::SimulationControl::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_timestamp;
    scdr << (uint32_t)m_type;
    scdr << m_educational_encounter;
}

void AMM::SimulationControl::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_timestamp;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_type = (AMM::ControlType)enum_value;
    }
    dcdr >> m_educational_encounter;
}

size_t AMM::SimulationControl::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool AMM::SimulationControl::isKeyDefined()
{
    return false;
}

void AMM::SimulationControl::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}

AMM::Status::Status()
{




    m_timestamp = 0;

    m_value = AMM::OPERATIONAL;



}

AMM::Status::~Status()
{
}

AMM::Status::Status(const Status &x)
{
    m_module_id = x.m_module_id;
    m_module_name = x.m_module_name;
    m_educational_encounter = x.m_educational_encounter;
    m_capability = x.m_capability;
    m_timestamp = x.m_timestamp;
    m_value = x.m_value;
    m_message = x.m_message;
}

AMM::Status::Status(Status &&x)
{
    m_module_id = std::move(x.m_module_id);
    m_module_name = std::move(x.m_module_name);
    m_educational_encounter = std::move(x.m_educational_encounter);
    m_capability = std::move(x.m_capability);
    m_timestamp = x.m_timestamp;
    m_value = x.m_value;
    m_message = std::move(x.m_message);
}

AMM::Status& AMM::Status::operator=(const Status &x)
{
    m_module_id = x.m_module_id;
    m_module_name = x.m_module_name;
    m_educational_encounter = x.m_educational_encounter;
    m_capability = x.m_capability;
    m_timestamp = x.m_timestamp;
    m_value = x.m_value;
    m_message = x.m_message;

    return *this;
}

AMM::Status& AMM::Status::operator=(Status &&x)
{
    m_module_id = std::move(x.m_module_id);
    m_module_name = std::move(x.m_module_name);
    m_educational_encounter = std::move(x.m_educational_encounter);
    m_capability = std::move(x.m_capability);
    m_timestamp = x.m_timestamp;
    m_value = x.m_value;
    m_message = std::move(x.m_message);

    return *this;
}

size_t AMM::Status::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Status::getCdrSerializedSize(const AMM::Status& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += AMM::UUID::getCdrSerializedSize(data.module_id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.module_name().size() + 1;

    current_alignment += AMM::UUID::getCdrSerializedSize(data.educational_encounter(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.capability().size() + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.message().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Status::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_module_id;
    scdr << m_module_name;
    scdr << m_educational_encounter;
    scdr << m_capability;
    scdr << m_timestamp;
    scdr << (uint32_t)m_value;
    scdr << m_message;
}

void AMM::Status::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_module_id;
    dcdr >> m_module_name;
    dcdr >> m_educational_encounter;
    dcdr >> m_capability;
    dcdr >> m_timestamp;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_value = (AMM::StatusValue)enum_value;
    }
    dcdr >> m_message;
}

size_t AMM::Status::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            








    return current_align;
}

bool AMM::Status::isKeyDefined()
{
    return false;
}

void AMM::Status::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
}
